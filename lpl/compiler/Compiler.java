package lpl.compiler;

import lpl.ast.*;
import static lpl.compiler.IRUtils.*;

import java.util.ArrayList;
import java.util.List;
import ir.ast.*;
import lpl.ast.util.VisitorAdapter;

public class Compiler extends VisitorAdapter<IRExp> {

    /**
     * The IR instruction sequence generated by the compiler so far.
     */
    private final List<IRStm> emitted;
    
    // Note: you may need to add additional fields to complete your implementation

    /**
     * Initialise a new compiler.
     */
    public Compiler() {
        emitted = new ArrayList<>();
    }

    /**
     * Add a new IR statement to the list of emitted instructions.
     *
     * @param s the IR statement to emit
     */
    private void emit(IRStm s) {
        emitted.add(s);
    }

    /**
     * Compile an LPL program into an IR program.
     * @param p the LPL program
     * @return the IR program
     */
    public IRProgram compile(Program p) {
        emitted.clear();
        
        // Prototype: here we assume there is just one function definition
        // (the "main" function) and that it expects no parameters, so we just
        // compile the body of the main function.
        // A complete solution will instead emit a CALL to the main function
        // (with actual parameter values retrieved from the stack), then
        // a JUMP to _END, followed by the compiled versions of all the
        // function definitions (including the main function).
        for (Stm s: p.main.ss) {
            s.accept(this);
        }
        emit(JUMP(NAME("_END")));

        IRProgram irp = new IRProgram(emitted);
        return irp;
    }

    @Override
    public IRExp visit(StmAssign s) {
        IRExp ire = s.e.accept(this);
        emit(MOVE(TEMP(s.id), ire));
        return null;
    }

    @Override
    public IRExp visit(PrimaryExpInteger n) {
        return CONST(n.i);
    }
    
    @Override
    public IRExp visit(ExpPrimaryExp e) {
        // an ExpPrimaryExp is just a PrimaryExp wrapped up as an Exp,
        // so we just compile the PrimaryExp that it contains
        return e.e.accept(this);
    }
    
    /// i started cw2
    @Override
    public IRExp visit(PrimaryExpTrue e) {
        return CONST(1);
    }
    
    @Override
    public IRExp visit(PrimaryExpFalse e) {
        return CONST(0);
    }
    
    @Override
    public IRExp visit(PrimaryExpNot e) {
        IRExp ire = e.e.accept(this);
        return BINOP(ire, EQ, CONST 0);
    } 
    
    @Override
    public IRExp visit(StmBlock stm) {
        for (Stm s : stm.ss) {
            s.accept(this);
        }
        return null;
    }
    
    @Override
    public IRExp visit(StmIf stm) {
    IRExp ire1 = stm.e.accept(this);
    String s1 = freshLab();
    String s2 = freshLab();
    String endLab = freshLab();
        
    emit(CJUMP(ire1, EQ, CONST(1), s1, s2));
    emit(LABEL(s1));
    stm.st.accept(this);
    emit(JUMP(NAME(endLab)));
    emit(LABEL(s2));
    stm.sf.accept(this);
    emit(LABEL(endLab));
    return null;
}
    
    @Override
    public IRExp visit(StmWhile stm) {
    }
    @Override
    public IRExp visit(ExpCall c) {
    }
    @Override
    public IRExp visit(StmCall c) {
    }
    @Override
    public IRExp visit(PrimaryExpVar v) {
    }
    @Override
    public IRExp visit(FunDef fd) {
    }
    @Override
    public IRExp visit(StmReturn s) {
    }
    @Override
    public IRExp visit(FunDef fd) {
    }
    
}

//ESEQ is for array creation
// but it would not use a const
//similar to code on lec 10 page 28
//ESEQ(SEQ(MOVE(TEMP x, CALL(NAME _malloc, CONST 17)),
//MOVE(MEM (TEMP x), CONST 101)
//),
//TEMP x
//)


// 